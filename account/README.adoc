= Account Manager Example
Peter Lawrey

This example shows a simple microservice accessible via TCP storing each message in and out via a Chronicle Queue

== Layouts

The client and the service can be liad out in a variety of ways without changing the code

=== TCP Client, TCP Service

This approach offers the most distributed option. The typical latencies are under 20 &micro;s with the 99%ile latency not much higher.

[source,mermaid]
....
sequenceDiagram
autonumber
Client->>Gateway: transfer
Note over Client,Gateway: via TCP, persisted
Gateway->>+Service: transfer
Note right of Gateway: via TCP
Note right of Service: processes event
Service->>-Gateway: onTransfer
Note over Service,Gateway: via TCP, persisted
Gateway->>Client: onTransfer
Note left of Gateway: via TCP
....

This can be benchmarked all in one with the command line properties `-Durl=tcp://localhost:1248 -DserviceUrl=tcp://:1248` running `AccountManagerBenchmarkMain`

=== TCP Client, Shared Memory Service

This approach offers the most distributed option. The typical latencies are around 10 &micro;s with the 99%ile latency not much higher.

[source,mermaid]
....
sequenceDiagram
autonumber
Client->>Gateway: transfer
Note over Client,Gateway: via TCP, persisted
Gateway->>+Service: transfer
Note right of Gateway: via Shared Memory
Note right of Service: processes event
Service->>-Gateway: onTransfer
Note over Service,Gateway: via Shared Memory, persisted
Gateway->>Client: onTransfer
Note left of Gateway: via TCP
....

This can be benchmarked all in one with the command line properties `-Durl=tcp://:1248` running `AccountManagerBenchmarkMain`

=== Shared Memory Client and Service

This approach offers the most distributed option. The typical latencies are under 2 &micro;s with the 99%ile latency about double this.

[source,mermaid]
....
sequenceDiagram
autonumber
Client->>queue: transfer
Note over Client,queue: via Shared Memory, persisted
queue->>+Service: transfer
Note right of queue: via Shared Memory
Note right of Service: processes event
Service->>-queue: onTransfer
Note over Service,queue: via Shared Memory, persisted
queue->>Client: onTransfer
Note left of queue: via Shared Memory
....

This can be benchmarked all in one with the default command line properties running `AccountManagerBenchmarkMain`

== Package Structure

We lay out our packages in the following manner

- `api` package for the input and output interfaces.
The input of one microservice might be the output of another microservice.
- `dto` package for POJOs (Plain Old Java Objects) that hold the data associated with each event.
- `impl` package for the service implementation and the high level classes it uses
- `util` package for separating low level helper methods and classes.

For demos, we might include `main` classes, however for a production system, we use a framework Chronicle Services https://chronicle.software/services/ to handle manageability, monitoring, restart and fail over.

=== Main methods

`AccountManagerServiceMain` runs the end service responsible for holding state and generating results of transactions

`AccountManagerGatewayMain` acts as a gateway listening for TCP connections and writing to/reading from the shared memory queue the microservices uses

`AccountManagerClientMain` injects a few simple messages and waits for resulting events from the AccountManagerImpl

`AccountManagerBenchmarkMain` runs a `JLBH` benchmark to report on the latency distribution running on your machine.
