= Account Manager Example
Peter Lawrey

This example shows a simple microservice accessible via TCP or shared memory storing each message in and out via a Chronicle Queue in a number of configurations with a comparison of the performance

This Account Management System is designed to handle basic account operations such as account creation and fund transfers.
It's built on Chronicle Wire and uses Fluent Interface pattern, taking advantage of YAML files for test input data.

== Features

. *Account Creation*: You can create new accounts with details such as account holder's name, account ID, currency type, and initial balance.
. *Fund Transfers*: The system can process fund transfers between different accounts.
. *Checkpoints*: The system can perform checkpoints, a way of marking a specific point in the sequence of operations.

== Network Layouts

The client and the service can be laid out in a variety of ways without changing the code

=== TCP Client, TCP Service

This approach offers the most distributed option.
The typical latencies are under 20 &micro;s with the 99%ile latency not much higher.

[source,mermaid]
....
sequenceDiagram
autonumber
Client->>Gateway: transfer
Note over Client,Gateway: via TCP, persisted
Gateway->>+Service: transfer
Note right of Gateway: via TCP
Note right of Service: processes event
Service->>-Gateway: onTransfer
Note over Service,Gateway: via TCP, persisted
Gateway->>Client: onTransfer
Note left of Gateway: via TCP
....

This can be benchmarked all in one with the command line properties `-Durl=tcp://localhost:1248 -DserviceUrl=tcp://:1248` running `AccountManagerBenchmarkMain`

=== TCP Client, Shared Memory Service

This approach offers the most distributed option. The typical latencies are around 10 &micro;s with the 99%ile latency not much higher.

[source,mermaid]
....
sequenceDiagram
autonumber
Client->>Gateway: transfer
Note over Client,Gateway: via TCP, persisted
Gateway->>+Service: transfer
Note right of Gateway: via Shared Memory
Note right of Service: processes event
Service->>-Gateway: onTransfer
Note over Service,Gateway: via Shared Memory, persisted
Gateway->>Client: onTransfer
Note left of Gateway: via TCP
....

This can be benchmarked all in one with the command line properties `-Durl=tcp://:1248` running `AccountManagerBenchmarkMain`

=== Shared Memory Client and Service

This approach offers the most distributed option. The typical latencies are under 2 &micro;s with the 99%ile latency about double this.

[source,mermaid]
....
sequenceDiagram
autonumber
Client->>queue: transfer
Note over Client,queue: via Shared Memory, persisted
queue->>+Service: transfer
Note right of queue: via Shared Memory
Note right of Service: processes event
Service->>-queue: onTransfer
Note over Service,queue: via Shared Memory, persisted
queue->>Client: onTransfer
Note left of queue: via Shared Memory
....

This can be benchmarked all in one with the default command line properties running `AccountManagerBenchmarkMain`

== Package Structure

We lay out our packages in the following manner

- `api` package for the input and output interfaces.
The input of one microservice might be the output of another microservice.
- `dto` package for POJOs (Plain Old Java Objects) that hold the data associated with each event.
- `impl` package for the service implementation and the high level classes it uses
- `util` package for separating low level helper methods and classes.

For demos, we might include `main` classes, however for a production system, we use a framework Chronicle Services https://chronicle.software/services/ to handle manageability, monitoring, restart and fail over.

=== Main methods

`AccountManagerServiceMain` runs the end service responsible for holding state and generating results of transactions

`AccountManagerGatewayMain` acts as a gateway listening for TCP connections and writing to/reading from the shared memory queue the microservices uses

`AccountManagerClientMain` injects a few simple messages and waits for resulting events from the AccountManagerImpl

`AccountManagerBenchmarkMain` runs a `JLBH` benchmark to report on the latency distribution running on your machine.

== Prerequisites

You need Java 8 or above installed on your machine to run this system.

== How to Run

. Compile the source files using your preferred Java compiler.
. Run the `main` function in the `AccountManagerServiceMain` class.
This will start the account management service.

Input data is provided through YAML files, where each operation (account creation or transfer) is defined in a separate document.

== Input Data Format

Input data is given in YAML format.
Here's an example of an account creation:

[source,yaml]
----
# Creating an account for Alice with 1000 EUR
createAccount: {
  sender: gw1,
  target: vault,
  sendingTime: 2023-01-20T10:00:00,
  name: alice,
  account: 101013,
  currency: EUR,
  balance: 1000
}
----

And an example of a transfer:

[source,yaml]
----
# Alice sends 10 EUR to Bob
transfer: {
  sender: gw2,
  target: vault,
  sendingTime: 2023-01-20T10:03:00,
  from: 101013,
  to: 101025,
  currency: EUR,
  amount: 10,
  reference: Dog food
}
----

== Note

This is a basic implementation and does not handle many edge cases.
It also lacks a user-friendly interface, and the input is provided directly through YAML files.
It's intended as a demonstration of a system built on Chronicle Wire, and may not be suitable for production use without further modifications and improvements.

== Contribute

We would love your contributions!
Please submit a pull request with any improvements or bug fixes you have made.
